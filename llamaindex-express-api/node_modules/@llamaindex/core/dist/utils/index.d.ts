import * as ___llms from '../llms/index.js';
import { LLMChat, LLM, MessageContent, MessageContentDetail } from '../llms/index.js';
import { QueryType } from '../query-engine/index.js';
import { ImageType } from '../schema/index.js';

declare function wrapEventCaller<This, Result, Args extends unknown[]>(originalMethod: (this: This, ...args: Args) => Result, context: ClassMethodDecoratorContext<object>): (this: This, ...args: Args) => Result;

declare function wrapLLMEvent<AdditionalChatOptions extends object = object, AdditionalMessageOptions extends object = object>(originalMethod: LLMChat<AdditionalChatOptions, AdditionalMessageOptions>["chat"], _context: ClassMethodDecoratorContext): (this: LLM<AdditionalChatOptions, AdditionalMessageOptions>, params: ___llms.LLMChatParamsStreaming<AdditionalChatOptions, object> | ___llms.LLMChatParamsNonStreaming<AdditionalChatOptions, object>) => ReturnType<LLMChat<AdditionalChatOptions, AdditionalMessageOptions>["chat"]>;

/**
 * Extracts just the text whether from
 *  a multi-modal message
 *  a single text message
 *  or a query
 *
 * @param message The message to extract text from.
 * @returns The extracted text
 */
declare function extractText(message: MessageContent | QueryType): string;
/**
 * Extracts a single text from a multi-modal message content
 *
 * @param message The message to extract images from.
 * @returns The extracted images
 */
declare function extractSingleText(message: MessageContentDetail): string | null;
/**
 * Extracts an image from a multi-modal message content
 *
 * @param message The message to extract images from.
 * @returns The extracted images
 */
declare function extractImage(message: MessageContentDetail): ImageType | null;
declare const extractDataUrlComponents: (dataUrl: string) => {
    mimeType: string;
    base64: string;
};

declare function streamConverter<S, D>(stream: AsyncIterable<S>, converter: (s: S) => D | null): AsyncIterable<D>;
declare function streamCallbacks<S>(stream: AsyncIterable<S>, callbacks: {
    finished?: (value?: S) => void;
}): AsyncIterable<S>;
declare function streamReducer<S, D>(params: {
    stream: AsyncIterable<S>;
    reducer: (previousValue: D, currentValue: S) => D;
    initialValue: D;
    finished?: (value: D) => void;
}): AsyncIterable<S>;

export { extractDataUrlComponents, extractImage, extractSingleText, extractText, streamCallbacks, streamConverter, streamReducer, wrapEventCaller, wrapLLMEvent };
