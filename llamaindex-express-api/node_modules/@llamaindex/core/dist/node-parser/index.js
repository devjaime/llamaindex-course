import { Settings } from '../global/index.js';
import { TransformComponent, MetadataMode, NodeRelationship, buildNodeFromSplits, sentenceSplitterSchema, sentenceWindowNodeParserSchema } from '../schema/index.js';
import { randomUUID } from '@llamaindex/env';

class NodeParser extends TransformComponent {
    constructor(){
        super(async (nodes)=>{
            return this.getNodesFromDocuments(nodes);
        });
        this.includeMetadata = true;
        this.includePrevNextRel = true;
    }
    postProcessParsedNodes(nodes, parentDocMap) {
        nodes.forEach((node, i)=>{
            const parentDoc = parentDocMap.get(node.sourceNode?.nodeId || "");
            if (parentDoc) {
                const startCharIdx = parentDoc.text.indexOf(node.getContent(MetadataMode.NONE));
                if (startCharIdx >= 0) {
                    node.startCharIdx = startCharIdx;
                    node.endCharIdx = startCharIdx + node.getContent(MetadataMode.NONE).length;
                }
                if (this.includeMetadata && node.metadata && parentDoc.metadata) {
                    node.metadata = {
                        ...node.metadata,
                        ...parentDoc.metadata
                    };
                }
            }
            if (this.includePrevNextRel && node.sourceNode) {
                const previousNode = i > 0 ? nodes[i - 1] : null;
                const nextNode = i < nodes.length - 1 ? nodes[i + 1] : null;
                if (previousNode && previousNode.sourceNode && previousNode.sourceNode.nodeId === node.sourceNode.nodeId) {
                    node.relationships = {
                        ...node.relationships,
                        [NodeRelationship.PREVIOUS]: previousNode.asRelatedNodeInfo()
                    };
                }
                if (nextNode && nextNode.sourceNode && nextNode.sourceNode.nodeId === node.sourceNode.nodeId) {
                    node.relationships = {
                        ...node.relationships,
                        [NodeRelationship.NEXT]: nextNode.asRelatedNodeInfo()
                    };
                }
            }
        });
        return nodes;
    }
    getNodesFromDocuments(documents) {
        const docsId = new Map(documents.map((doc)=>[
                doc.id_,
                doc
            ]));
        const callbackManager = Settings.callbackManager;
        callbackManager.dispatchEvent("node-parsing-start", {
            documents
        });
        const nodes = this.postProcessParsedNodes(this.parseNodes(documents), docsId);
        callbackManager.dispatchEvent("node-parsing-end", {
            nodes
        });
        return nodes;
    }
}
class TextSplitter extends NodeParser {
    splitTexts(texts) {
        return texts.flatMap((text)=>this.splitText(text));
    }
    parseNodes(nodes) {
        return nodes.reduce((allNodes, node)=>{
            const splits = this.splitText(node.getContent(MetadataMode.ALL));
            const nodes = buildNodeFromSplits(splits, node);
            return allNodes.concat(nodes);
        }, []);
    }
}
class MetadataAwareTextSplitter extends TextSplitter {
    splitTextsMetadataAware(texts, metadata) {
        if (texts.length !== metadata.length) {
            throw new TypeError("`texts` and `metadata` must have the same length");
        }
        return texts.flatMap((text, i)=>this.splitTextMetadataAware(text, metadata[i]));
    }
    getMetadataString(node) {
        const embedStr = node.getMetadataStr(MetadataMode.EMBED);
        const llmStr = node.getMetadataStr(MetadataMode.LLM);
        if (embedStr.length > llmStr.length) {
            return embedStr;
        } else {
            return llmStr;
        }
    }
    parseNodes(nodes) {
        return nodes.reduce((allNodes, node)=>{
            const metadataStr = this.getMetadataString(node);
            const splits = this.splitTextMetadataAware(node.getContent(MetadataMode.NONE), metadataStr);
            return allNodes.concat(buildNodeFromSplits(splits, node));
        }, []);
    }
}

var __getOwnPropNames = Object.getOwnPropertyNames;
var cjs = (cb, mod)=>function _r() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
// lib/natural/util/abbreviations_en.js
var require_abbreviations_en = cjs({
    "lib/natural/util/abbreviations_en.js" (exports) {
        var knownAbbreviations = [
            "approx.",
            "appt.",
            "apt.",
            "A.S.A.P.",
            "B.Y.O.B.",
            "c/o",
            "dept.",
            "D.I.Y.",
            "est.",
            "E.T.A.",
            "Inc.",
            "min.",
            "misc.",
            "Mr.",
            "Mrs.",
            "no.",
            "R.S.V.P.",
            "tel.",
            "temp.",
            "vet.",
            "vs."
        ];
        exports.knownAbbreviations = knownAbbreviations;
    }
});
// lib/natural/tokenizers/parser_sentence_tokenizer.js
var require_parser_sentence_tokenizer = cjs({
    "lib/natural/tokenizers/parser_sentence_tokenizer.js" (exports, module) {
        function peg$subclass(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
        }
        function peg$SyntaxError(message, expected, found, location) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.location = location;
            this.name = "SyntaxError";
            if (typeof Error.captureStackTrace === "function") {
                Error.captureStackTrace(this, peg$SyntaxError);
            }
        }
        peg$subclass(peg$SyntaxError, Error);
        peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
                literal: function(expectation) {
                    return '"' + literalEscape(expectation.text) + '"';
                },
                class: function(expectation) {
                    var escapedParts = "", i;
                    for(i = 0; i < expectation.parts.length; i++){
                        escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
                    }
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                },
                any: function(expectation) {
                    return "any character";
                },
                end: function(expectation) {
                    return "end of input";
                },
                other: function(expectation) {
                    return expectation.description;
                }
            };
            function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
                return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                    return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                    return "\\x" + hex(ch);
                });
            }
            function classEscape(s) {
                return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                    return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                    return "\\x" + hex(ch);
                });
            }
            function describeExpectation(expectation) {
                return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
                var descriptions = new Array(expected2.length), i, j;
                for(i = 0; i < expected2.length; i++){
                    descriptions[i] = describeExpectation(expected2[i]);
                }
                descriptions.sort();
                if (descriptions.length > 0) {
                    for(i = 1, j = 1; i < descriptions.length; i++){
                        if (descriptions[i - 1] !== descriptions[i]) {
                            descriptions[j] = descriptions[i];
                            j++;
                        }
                    }
                    descriptions.length = j;
                }
                switch(descriptions.length){
                    case 1:
                        return descriptions[0];
                    case 2:
                        return descriptions[0] + " or " + descriptions[1];
                    default:
                        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
                }
            }
            function describeFound(found2) {
                return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
            options = options !== void 0 ? options : {};
            var peg$FAILED = {}, peg$startRuleFunctions = {
                s: peg$parses
            }, peg$startRuleFunction = peg$parses, peg$c0 = function(sentences) {
                const result = [];
                sentences.forEach((sent0)=>{
                    sent0[0].forEach((sent1)=>{
                        result.push(sent1);
                    });
                });
                return result;
            }, peg$c1 = function(sentences) {
                return sentences.map((sent)=>{
                    sent[0].push(sent[1]);
                    return sent[0].reduce((accu, str)=>accu + str).trim();
                });
            }, peg$c2 = function(open, sentences, close) {
                const result = sentences.map((sent)=>{
                    sent[0].push(sent[1]);
                    return sent[0].reduce((accu, str)=>accu + str).trim();
                });
                result.unshift(open);
                if (close) {
                    result.push(close);
                }
                return result;
            }, peg$c3 = function(seqs, end) {
                const res = seqs.reduce((accu, seq)=>accu.concat(seq));
                res.push(end);
                return res;
            }, peg$c4 = function(tokens) {
                const result = tokens.map((pair)=>pair[0] + pair[1]);
                return result;
            }, peg$c5 = function(open, tokens, end, close) {
                const result = tokens.map((pair)=>pair[0] + pair[1]);
                result.unshift(open);
                result.push(end);
                result.push(close);
                return result;
            }, peg$c6 = /^[ \t\n\r.?!]/, peg$c7 = peg$classExpectation([
                " ",
                "	",
                "\n",
                "\r",
                ".",
                "?",
                "!"
            ], false, false), peg$c8 = function() {
                return text();
            }, peg$c9 = /^[ \t\n\r]/, peg$c10 = peg$classExpectation([
                " ",
                "	",
                "\n",
                "\r"
            ], false, false), peg$c11 = function(t) {
                return t;
            }, peg$c12 = /^[^ \t\n\r!?([}"`)\]}"`0-9@]/, peg$c13 = peg$classExpectation([
                " ",
                "	",
                "\n",
                "\r",
                "!",
                "?",
                "(",
                "[",
                "}",
                '"',
                "`",
                ")",
                "]",
                "}",
                '"',
                "`",
                [
                    "0",
                    "9"
                ],
                "@"
            ], true, false), peg$c14 = function(word) {
                const tmp = word.reduce((accu, elt)=>accu + elt);
                return knownAbbreviations.indexOf(tmp) > -1;
            }, peg$c15 = function(word) {
                return text();
            }, peg$c16 = /^[^ \t\n\r!?.([})\]}`"0-9@]/, peg$c17 = peg$classExpectation([
                " ",
                "	",
                "\n",
                "\r",
                "!",
                "?",
                ".",
                "(",
                "[",
                "}",
                ")",
                "]",
                "}",
                "`",
                '"',
                [
                    "0",
                    "9"
                ],
                "@"
            ], true, false), peg$c18 = function() {
                return text();
            }, peg$c19 = /^[0-9]/, peg$c20 = peg$classExpectation([
                [
                    "0",
                    "9"
                ]
            ], false, false), peg$c21 = peg$anyExpectation(), peg$c22 = /^[a-z]/, peg$c23 = peg$classExpectation([
                [
                    "a",
                    "z"
                ]
            ], false, false), peg$c24 = /^[@]/, peg$c25 = peg$classExpectation([
                "@"
            ], false, false), peg$c26 = /^[.]/, peg$c27 = peg$classExpectation([
                "."
            ], false, false), peg$c28 = "http://", peg$c29 = peg$literalExpectation("http://", false), peg$c30 = "https://", peg$c31 = peg$literalExpectation("https://", false), peg$c32 = /^[a-z0-9]/, peg$c33 = peg$classExpectation([
                [
                    "a",
                    "z"
                ],
                [
                    "0",
                    "9"
                ]
            ], false, false), peg$c34 = /^[\/]/, peg$c35 = peg$classExpectation([
                "/"
            ], false, false), peg$c36 = function() {
                return text();
            }, peg$c37 = /^[([{"'`\u2018]/, peg$c38 = peg$classExpectation([
                "(",
                "[",
                "{",
                '"',
                "'",
                "`",
                "\u2018"
            ], false, false), peg$c39 = /^[)\]}"'`\u2019]/, peg$c40 = peg$classExpectation([
                ")",
                "]",
                "}",
                '"',
                "'",
                "`",
                "\u2019"
            ], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [
                {
                    line: 1,
                    column: 1
                }
            ], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$result;
            if ("startRule" in options) {
                if (!(options.startRule in peg$startRuleFunctions)) {
                    throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
                }
                peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
            }
            function text() {
                return input.substring(peg$savedPos, peg$currPos);
            }
            function peg$literalExpectation(text2, ignoreCase) {
                return {
                    type: "literal",
                    text: text2,
                    ignoreCase
                };
            }
            function peg$classExpectation(parts, inverted, ignoreCase) {
                return {
                    type: "class",
                    parts,
                    inverted,
                    ignoreCase
                };
            }
            function peg$anyExpectation() {
                return {
                    type: "any"
                };
            }
            function peg$endExpectation() {
                return {
                    type: "end"
                };
            }
            function peg$computePosDetails(pos) {
                var details = peg$posDetailsCache[pos], p;
                if (details) {
                    return details;
                } else {
                    p = pos - 1;
                    while(!peg$posDetailsCache[p]){
                        p--;
                    }
                    details = peg$posDetailsCache[p];
                    details = {
                        line: details.line,
                        column: details.column
                    };
                    while(p < pos){
                        if (input.charCodeAt(p) === 10) {
                            details.line++;
                            details.column = 1;
                        } else {
                            details.column++;
                        }
                        p++;
                    }
                    peg$posDetailsCache[pos] = details;
                    return details;
                }
            }
            function peg$computeLocation(startPos, endPos) {
                var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
                return {
                    start: {
                        offset: startPos,
                        line: startPosDetails.line,
                        column: startPosDetails.column
                    },
                    end: {
                        offset: endPos,
                        line: endPosDetails.line,
                        column: endPosDetails.column
                    }
                };
            }
            function peg$fail(expected2) {
                if (peg$currPos < peg$maxFailPos) {
                    return;
                }
                if (peg$currPos > peg$maxFailPos) {
                    peg$maxFailPos = peg$currPos;
                    peg$maxFailExpected = [];
                }
                peg$maxFailExpected.push(expected2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
                return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
            }
            function peg$parses() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$currPos;
                s3 = peg$parseSentences();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseWhitespace();
                    if (s4 !== peg$FAILED) {
                        s3 = [
                            s3,
                            s4
                        ];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseQuotedSentences();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseWhitespace();
                        if (s4 !== peg$FAILED) {
                            s3 = [
                                s3,
                                s4
                            ];
                            s2 = s3;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        s2 = peg$currPos;
                        s3 = peg$parseSentences();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parseWhitespace();
                            if (s4 !== peg$FAILED) {
                                s3 = [
                                    s3,
                                    s4
                                ];
                                s2 = s3;
                            } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                        if (s2 === peg$FAILED) {
                            s2 = peg$currPos;
                            s3 = peg$parseQuotedSentences();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseWhitespace();
                                if (s4 !== peg$FAILED) {
                                    s3 = [
                                        s3,
                                        s4
                                    ];
                                    s2 = s3;
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c0(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseSentences() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$currPos;
                s3 = peg$parseSentence();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseWhitespace();
                    if (s4 !== peg$FAILED) {
                        s3 = [
                            s3,
                            s4
                        ];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        s2 = peg$currPos;
                        s3 = peg$parseSentence();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parseWhitespace();
                            if (s4 !== peg$FAILED) {
                                s3 = [
                                    s3,
                                    s4
                                ];
                                s2 = s3;
                            } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c1(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseQuotedSentences() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                s1 = peg$parseOpenSymbol();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parseSentence();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseWhitespace();
                        if (s5 !== peg$FAILED) {
                            s4 = [
                                s4,
                                s5
                            ];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                        while(s3 !== peg$FAILED){
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$parseSentence();
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseWhitespace();
                                if (s5 !== peg$FAILED) {
                                    s4 = [
                                        s4,
                                        s5
                                    ];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseCloseSymbol();
                        if (s3 === peg$FAILED) {
                            s3 = null;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c2(s1, s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseSentence() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parseTokenSeq();
                if (s2 === peg$FAILED) {
                    s2 = peg$parseQuotedTokenSeq();
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        s2 = peg$parseTokenSeq();
                        if (s2 === peg$FAILED) {
                            s2 = peg$parseQuotedTokenSeq();
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseEndOfSentence();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c3(s1, s2);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTokenSeq() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$currPos;
                s3 = peg$parseToken();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseWhitespace();
                    if (s4 !== peg$FAILED) {
                        s3 = [
                            s3,
                            s4
                        ];
                        s2 = s3;
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        s2 = peg$currPos;
                        s3 = peg$parseToken();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parseWhitespace();
                            if (s4 !== peg$FAILED) {
                                s3 = [
                                    s3,
                                    s4
                                ];
                                s2 = s3;
                            } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c4(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseQuotedTokenSeq() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                s1 = peg$parseOpenSymbol();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parseToken();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseWhitespace();
                        if (s5 !== peg$FAILED) {
                            s4 = [
                                s4,
                                s5
                            ];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                        while(s3 !== peg$FAILED){
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$parseToken();
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseWhitespace();
                                if (s5 !== peg$FAILED) {
                                    s4 = [
                                        s4,
                                        s5
                                    ];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseEndOfSentence();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parseCloseSymbol();
                            if (s4 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c5(s1, s2, s3, s4);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseEndOfSentence() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c6.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c7);
                    }
                }
                while(s2 !== peg$FAILED){
                    s1.push(s2);
                    if (peg$c6.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c7);
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c8();
                }
                s0 = s1;
                return s0;
            }
            function peg$parseWhitespace() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c9.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c10);
                    }
                }
                while(s2 !== peg$FAILED){
                    s1.push(s2);
                    if (peg$c9.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c10);
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c8();
                }
                s0 = s1;
                return s0;
            }
            function peg$parseToken() {
                var s0, s1;
                s0 = peg$currPos;
                s1 = peg$parseURI();
                if (s1 === peg$FAILED) {
                    s1 = peg$parseEmail();
                    if (s1 === peg$FAILED) {
                        s1 = peg$parseNumber();
                        if (s1 === peg$FAILED) {
                            s1 = peg$parseAbbreviation();
                            if (s1 === peg$FAILED) {
                                s1 = peg$parseWord();
                            }
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseAbbreviation() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c12.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c13);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        if (peg$c12.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c13);
                            }
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s2 = peg$c14(s1);
                    if (s2) {
                        s2 = void 0;
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c15();
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseWord() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c16.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c17);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        if (peg$c16.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c17);
                            }
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c18();
                }
                s0 = s1;
                return s0;
            }
            function peg$parseNumber() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c19.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c20);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        if (peg$c19.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c20);
                            }
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    if (input.length > peg$currPos) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        {
                            peg$fail(peg$c21);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = [];
                        if (peg$c19.test(input.charAt(peg$currPos))) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            {
                                peg$fail(peg$c20);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            while(s5 !== peg$FAILED){
                                s4.push(s5);
                                if (peg$c19.test(input.charAt(peg$currPos))) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    {
                                        peg$fail(peg$c20);
                                    }
                                }
                            }
                        } else {
                            s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                            s3 = [
                                s3,
                                s4
                            ];
                            s2 = s3;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                    if (s2 === peg$FAILED) {
                        s2 = null;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseCloseSymbol();
                        if (s3 === peg$FAILED) {
                            s3 = null;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c8();
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseEmail() {
                var s0, s1, s2, s3, s4, s5, s6;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c22.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c23);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        if (peg$c22.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c23);
                            }
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    if (peg$c24.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c25);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        if (peg$c22.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c23);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            while(s4 !== peg$FAILED){
                                s3.push(s4);
                                if (peg$c22.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    {
                                        peg$fail(peg$c23);
                                    }
                                }
                            }
                        } else {
                            s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                            if (peg$c26.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c27);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = [];
                                if (peg$c22.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    {
                                        peg$fail(peg$c23);
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    while(s6 !== peg$FAILED){
                                        s5.push(s6);
                                        if (peg$c22.test(input.charAt(peg$currPos))) {
                                            s6 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            {
                                                peg$fail(peg$c23);
                                            }
                                        }
                                    }
                                } else {
                                    s5 = peg$FAILED;
                                }
                                if (s5 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c8();
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseURI() {
                var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 7) === peg$c28) {
                    s1 = peg$c28;
                    peg$currPos += 7;
                } else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c29);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c30) {
                        s1 = peg$c30;
                        peg$currPos += 8;
                    } else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c31);
                        }
                    }
                }
                if (s1 === peg$FAILED) {
                    s1 = null;
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    if (peg$c32.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        {
                            peg$fail(peg$c33);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        while(s3 !== peg$FAILED){
                            s2.push(s3);
                            if (peg$c32.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                {
                                    peg$fail(peg$c33);
                                }
                            }
                        }
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        if (peg$c26.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            {
                                peg$fail(peg$c27);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$currPos;
                            s5 = [];
                            if (peg$c32.test(input.charAt(peg$currPos))) {
                                s6 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s6 = peg$FAILED;
                                {
                                    peg$fail(peg$c33);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                while(s6 !== peg$FAILED){
                                    s5.push(s6);
                                    if (peg$c32.test(input.charAt(peg$currPos))) {
                                        s6 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        {
                                            peg$fail(peg$c33);
                                        }
                                    }
                                }
                            } else {
                                s5 = peg$FAILED;
                            }
                            if (s5 !== peg$FAILED) {
                                if (peg$c26.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    {
                                        peg$fail(peg$c27);
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    s5 = [
                                        s5,
                                        s6
                                    ];
                                    s4 = s5;
                                } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                            if (s4 === peg$FAILED) {
                                s4 = null;
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = [];
                                if (peg$c32.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    {
                                        peg$fail(peg$c33);
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    while(s6 !== peg$FAILED){
                                        s5.push(s6);
                                        if (peg$c32.test(input.charAt(peg$currPos))) {
                                            s6 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            {
                                                peg$fail(peg$c33);
                                            }
                                        }
                                    }
                                } else {
                                    s5 = peg$FAILED;
                                }
                                if (s5 !== peg$FAILED) {
                                    s6 = [];
                                    s7 = peg$currPos;
                                    s8 = [];
                                    if (peg$c32.test(input.charAt(peg$currPos))) {
                                        s9 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s9 = peg$FAILED;
                                        {
                                            peg$fail(peg$c33);
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        while(s9 !== peg$FAILED){
                                            s8.push(s9);
                                            if (peg$c32.test(input.charAt(peg$currPos))) {
                                                s9 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s9 = peg$FAILED;
                                                {
                                                    peg$fail(peg$c33);
                                                }
                                            }
                                        }
                                    } else {
                                        s8 = peg$FAILED;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        if (peg$c34.test(input.charAt(peg$currPos))) {
                                            s9 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s9 = peg$FAILED;
                                            {
                                                peg$fail(peg$c35);
                                            }
                                        }
                                        if (s9 !== peg$FAILED) {
                                            s8 = [
                                                s8,
                                                s9
                                            ];
                                            s7 = s8;
                                        } else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                    while(s7 !== peg$FAILED){
                                        s6.push(s7);
                                        s7 = peg$currPos;
                                        s8 = [];
                                        if (peg$c32.test(input.charAt(peg$currPos))) {
                                            s9 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s9 = peg$FAILED;
                                            {
                                                peg$fail(peg$c33);
                                            }
                                        }
                                        if (s9 !== peg$FAILED) {
                                            while(s9 !== peg$FAILED){
                                                s8.push(s9);
                                                if (peg$c32.test(input.charAt(peg$currPos))) {
                                                    s9 = input.charAt(peg$currPos);
                                                    peg$currPos++;
                                                } else {
                                                    s9 = peg$FAILED;
                                                    {
                                                        peg$fail(peg$c33);
                                                    }
                                                }
                                            }
                                        } else {
                                            s8 = peg$FAILED;
                                        }
                                        if (s8 !== peg$FAILED) {
                                            if (peg$c34.test(input.charAt(peg$currPos))) {
                                                s9 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s9 = peg$FAILED;
                                                {
                                                    peg$fail(peg$c35);
                                                }
                                            }
                                            if (s9 !== peg$FAILED) {
                                                s8 = [
                                                    s8,
                                                    s9
                                                ];
                                                s7 = s8;
                                            } else {
                                                peg$currPos = s7;
                                                s7 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    }
                                    if (s6 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c36();
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseOpenSymbol() {
                var s0, s1;
                s0 = peg$currPos;
                if (peg$c37.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c38);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c8();
                }
                s0 = s1;
                return s0;
            }
            function peg$parseCloseSymbol() {
                var s0, s1;
                s0 = peg$currPos;
                if (peg$c39.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c40);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c8();
                }
                s0 = s1;
                return s0;
            }
            const knownAbbreviations = require_abbreviations_en().knownAbbreviations;
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                return peg$result;
            } else {
                if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                    peg$fail(peg$endExpectation());
                }
                throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
            }
        }
        module.exports = {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
        };
    }
});
// lib/natural/tokenizers/tokenizer.js
var require_tokenizer = cjs({
    "lib/natural/tokenizers/tokenizer.js" (exports, module) {
        var Tokenizer = class {
            trim(array) {
                while(array[array.length - 1] === ""){
                    array.pop();
                }
                while(array[0] === ""){
                    array.shift();
                }
                return array;
            }
        };
        module.exports = Tokenizer;
    }
});
// lib/natural/tokenizers/sentence_tokenizer_parser.js
var require_sentence_tokenizer_parser = cjs({
    "lib/natural/tokenizers/sentence_tokenizer_parser.js" (exports, module) {
        var parser = require_parser_sentence_tokenizer();
        var Tokenizer = require_tokenizer();
        var SentenceTokenizer = class extends Tokenizer {
            tokenize(text) {
                return parser.parse(text);
            }
        };
        module.exports = SentenceTokenizer;
    }
});
var SentenceTokenizerNew = require_sentence_tokenizer_parser();

const splitTextKeepSeparator = (text, separator)=>{
    const parts = text.split(separator);
    const result = parts.map((part, index)=>index > 0 ? separator + part : part);
    return result.filter((s)=>s);
};
const splitBySep = (sep, keepSep = true)=>{
    if (keepSep) {
        return (text)=>splitTextKeepSeparator(text, sep);
    } else {
        return (text)=>text.split(sep);
    }
};
const splitByChar = ()=>{
    return (text)=>text.split("");
};
let sentenceTokenizer = null;
const splitBySentenceTokenizer = ()=>{
    if (!sentenceTokenizer) {
        sentenceTokenizer = new SentenceTokenizerNew();
    }
    const tokenizer = sentenceTokenizer;
    return (text)=>{
        try {
            return tokenizer.tokenize(text);
        } catch  {
            return [
                text
            ];
        }
    };
};
const splitByRegex = (regex)=>{
    return (text)=>text.match(new RegExp(regex, "g")) || [];
};
const splitByPhraseRegex = ()=>{
    const regex = "[^,.;]+[,.;]?";
    return splitByRegex(regex);
};

/**
 * Parse text with a preference for complete sentences.
 */ class SentenceSplitter extends MetadataAwareTextSplitter {
    #chunkingTokenizerFn;
    #splitFns;
    #subSentenceSplitFns;
    #tokenizer;
    constructor(params){
        super();
        /**
   * The token chunk size for each chunk.
   */ this.chunkSize = 1024;
        /**
   * The token overlap of each chunk when splitting.
   */ this.chunkOverlap = 200;
        /**
   * Default separator for splitting into words
   */ this.separator = " ";
        /**
   * Separator between paragraphs.
   */ this.paragraphSeparator = "\n\n\n";
        /**
   * Backup regex for splitting into sentences.
   */ this.secondaryChunkingRegex = "[^,.;。？！]+[,.;。？！]?";
        this.#chunkingTokenizerFn = splitBySentenceTokenizer();
        this.#splitFns = new Set();
        this.#subSentenceSplitFns = new Set();
        this.tokenSize = (text)=>this.#tokenizer.encode(text).length;
        if (params) {
            const parsedParams = sentenceSplitterSchema.parse(params);
            this.chunkSize = parsedParams.chunkSize;
            this.chunkOverlap = parsedParams.chunkOverlap;
            this.separator = parsedParams.separator;
            this.paragraphSeparator = parsedParams.paragraphSeparator;
            this.secondaryChunkingRegex = parsedParams.secondaryChunkingRegex;
        }
        this.#tokenizer = params?.tokenizer ?? Settings.tokenizer;
        this.#splitFns.add(splitBySep(this.paragraphSeparator));
        this.#splitFns.add(this.#chunkingTokenizerFn);
        this.#subSentenceSplitFns.add(splitByRegex(this.secondaryChunkingRegex));
        this.#subSentenceSplitFns.add(splitBySep(this.separator));
        this.#subSentenceSplitFns.add(splitByChar());
    }
    splitTextMetadataAware(text, metadata) {
        const metadataLength = this.tokenSize(metadata);
        const effectiveChunkSize = this.chunkSize - metadataLength;
        if (effectiveChunkSize <= 0) {
            throw new Error(`Metadata length (${metadataLength}) is longer than chunk size (${this.chunkSize}). Consider increasing the chunk size or decreasing the size of your metadata to avoid this.`);
        } else if (effectiveChunkSize < 50) {
            console.log(`Metadata length (${metadataLength}) is close to chunk size (${this.chunkSize}). Resulting chunks are less than 50 tokens. Consider increasing the chunk size or decreasing the size of your metadata to avoid this.`);
        }
        return this._splitText(text, effectiveChunkSize);
    }
    splitText(text) {
        return this._splitText(text, this.chunkSize);
    }
    _splitText(text, chunkSize) {
        if (text === "") return [
            text
        ];
        const callbackManager = Settings.callbackManager;
        callbackManager.dispatchEvent("chunking-start", {
            text: [
                text
            ]
        });
        const splits = this.#split(text, chunkSize);
        const chunks = this.#merge(splits, chunkSize);
        callbackManager.dispatchEvent("chunking-end", {
            chunks
        });
        return chunks;
    }
    #split(text, chunkSize) {
        const tokenSize = this.tokenSize(text);
        if (tokenSize <= chunkSize) {
            return [
                {
                    text,
                    isSentence: true,
                    tokenSize
                }
            ];
        }
        const [textSplitsByFns, isSentence] = this.#getSplitsByFns(text);
        const textSplits = [];
        for (const textSplit of textSplitsByFns){
            const tokenSize = this.tokenSize(textSplit);
            if (tokenSize <= chunkSize) {
                textSplits.push({
                    text: textSplit,
                    isSentence,
                    tokenSize
                });
            } else {
                const recursiveTextSplits = this.#split(textSplit, chunkSize);
                textSplits.push(...recursiveTextSplits);
            }
        }
        return textSplits;
    }
    #getSplitsByFns(text) {
        for (const splitFn of this.#splitFns){
            const splits = splitFn(text);
            if (splits.length > 1) {
                return [
                    splits,
                    true
                ];
            }
        }
        for (const splitFn of this.#subSentenceSplitFns){
            const splits = splitFn(text);
            if (splits.length > 1) {
                return [
                    splits,
                    false
                ];
            }
        }
        return [
            [
                text
            ],
            true
        ];
    }
    #merge(splits, chunkSize) {
        const chunks = [];
        let currentChunk = [];
        let lastChunk = [];
        let currentChunkLength = 0;
        let newChunk = true;
        const closeChunk = ()=>{
            chunks.push(currentChunk.map(([text])=>text).join(""));
            lastChunk = currentChunk;
            currentChunk = [];
            currentChunkLength = 0;
            newChunk = true;
            let lastIndex = lastChunk.length - 1;
            while(lastIndex >= 0 && currentChunkLength + lastChunk[lastIndex][1] <= this.chunkOverlap){
                const [text, length] = lastChunk[lastIndex];
                currentChunkLength += length;
                currentChunk.unshift([
                    text,
                    length
                ]);
                lastIndex -= 1;
            }
        };
        while(splits.length > 0){
            const curSplit = splits[0];
            if (curSplit.tokenSize > chunkSize) {
                throw new Error("Single token exceeded chunk size");
            }
            if (currentChunkLength + curSplit.tokenSize > chunkSize && !newChunk) {
                closeChunk();
            } else {
                if (curSplit.isSentence || currentChunkLength + curSplit.tokenSize <= chunkSize || newChunk) {
                    currentChunkLength += curSplit.tokenSize;
                    currentChunk.push([
                        curSplit.text,
                        curSplit.tokenSize
                    ]);
                    splits.shift();
                    newChunk = false;
                } else {
                    closeChunk();
                }
            }
        }
        // Handle the last chunk
        if (!newChunk) {
            chunks.push(currentChunk.map(([text])=>text).join(""));
        }
        return this.#postprocessChunks(chunks);
    }
    /**
   * Remove whitespace only chunks and remove leading and trailing whitespace.
   */ #postprocessChunks(chunks) {
        const newChunks = [];
        for (const chunk of chunks){
            const trimmedChunk = chunk.trim();
            if (trimmedChunk !== "") {
                newChunks.push(trimmedChunk);
            }
        }
        return newChunks;
    }
}

class MarkdownNodeParser extends NodeParser {
    parseNodes(nodes, showProgress) {
        return nodes.reduce((allNodes, node)=>{
            const markdownNodes = this.getNodesFromNode(node);
            return allNodes.concat(markdownNodes);
        }, []);
    }
    getNodesFromNode(node) {
        const text = node.getContent(MetadataMode.NONE);
        const markdownNodes = [];
        const lines = text.split("\n");
        let metadata = {};
        let codeBlock = false;
        let currentSection = "";
        for (const line of lines){
            if (line.trim().startsWith("```")) {
                codeBlock = !codeBlock;
            }
            const headerMatch = /^(#+)\s(.*)/.exec(line);
            if (headerMatch && !codeBlock) {
                if (currentSection !== "") {
                    markdownNodes.push(this.buildNodeFromSplit(currentSection.trim(), node, metadata));
                }
                metadata = this.updateMetadata(metadata, headerMatch[2], headerMatch[1].trim().length);
                currentSection = `${headerMatch[2]}\n`;
            } else {
                currentSection += line + "\n";
            }
        }
        if (currentSection !== "") {
            markdownNodes.push(this.buildNodeFromSplit(currentSection.trim(), node, metadata));
        }
        return markdownNodes;
    }
    updateMetadata(headersMetadata, newHeader, newHeaderLevel) {
        const updatedHeaders = {};
        for(let i = 1; i < newHeaderLevel; i++){
            const key = `Header_${i}`;
            if (key in headersMetadata) {
                updatedHeaders[key] = headersMetadata[key];
            }
        }
        updatedHeaders[`Header_${newHeaderLevel}`] = newHeader;
        return updatedHeaders;
    }
    buildNodeFromSplit(textSplit, node, metadata) {
        const newNode = buildNodeFromSplits([
            textSplit
        ], node, undefined)[0];
        if (this.includeMetadata) {
            newNode.metadata = {
                ...newNode.metadata,
                ...metadata
            };
        }
        return newNode;
    }
}

class SentenceWindowNodeParser extends NodeParser {
    static{
        this.DEFAULT_WINDOW_SIZE = 3;
    }
    static{
        this.DEFAULT_WINDOW_METADATA_KEY = "window";
    }
    static{
        this.DEFAULT_ORIGINAL_TEXT_METADATA_KEY = "originalText";
    }
    constructor(params){
        super();
        this.sentenceSplitter = splitBySentenceTokenizer();
        this.idGenerator = ()=>randomUUID();
        if (params) {
            const parsedParams = sentenceWindowNodeParserSchema.parse(params);
            this.windowSize = parsedParams.windowSize;
            this.windowMetadataKey = parsedParams.windowMetadataKey;
            this.originalTextMetadataKey = parsedParams.originalTextMetadataKey;
        } else {
            this.windowSize = SentenceWindowNodeParser.DEFAULT_WINDOW_SIZE;
            this.windowMetadataKey = SentenceWindowNodeParser.DEFAULT_WINDOW_METADATA_KEY;
            this.originalTextMetadataKey = SentenceWindowNodeParser.DEFAULT_ORIGINAL_TEXT_METADATA_KEY;
        }
    }
    parseNodes(nodes, showProgress) {
        return nodes.reduce((allNodes, node)=>{
            const nodes = this.buildWindowNodesFromDocuments([
                node
            ]);
            return allNodes.concat(nodes);
        }, []);
    }
    buildWindowNodesFromDocuments(documents) {
        const allNodes = [];
        for (const doc of documents){
            const text = doc.text;
            const textSplits = this.sentenceSplitter(text);
            const nodes = buildNodeFromSplits(textSplits, doc, undefined, this.idGenerator);
            nodes.forEach((node, i)=>{
                const windowNodes = nodes.slice(Math.max(0, i - this.windowSize), Math.min(i + this.windowSize + 1, nodes.length));
                node.metadata[this.windowMetadataKey] = windowNodes.map((n)=>n.text).join(" ");
                node.metadata[this.originalTextMetadataKey] = node.text;
                node.excludedEmbedMetadataKeys.push(this.windowMetadataKey, this.originalTextMetadataKey);
                node.excludedLlmMetadataKeys.push(this.windowMetadataKey, this.originalTextMetadataKey);
            });
            allNodes.push(...nodes);
        }
        return allNodes;
    }
}

/**
 * @deprecated Use `SentenceSplitter` instead
 */ const SimpleNodeParser = SentenceSplitter;

export { MarkdownNodeParser, MetadataAwareTextSplitter, NodeParser, SentenceSplitter, SentenceWindowNodeParser, SimpleNodeParser, TextSplitter, splitByChar, splitByPhraseRegex, splitByRegex, splitBySentenceTokenizer, splitBySep };
