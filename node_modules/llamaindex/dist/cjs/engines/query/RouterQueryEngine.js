"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouterQueryEngine", {
    enumerable: true,
    get: function() {
        return RouterQueryEngine;
    }
});
const _schema = require("@llamaindex/core/schema");
const _utils = require("@llamaindex/core/utils");
const _Settings = require("../../Settings.js");
const _index = require("../../prompts/index.js");
const _index1 = require("../../selectors/index.js");
const _index2 = require("../../synthesizers/index.js");
async function combineResponses(summarizer, responses, queryType, verbose = false) {
    if (verbose) {
        console.log("Combining responses from multiple query engines.");
    }
    const responseStrs = [];
    const sourceNodes = [];
    for (const response of responses){
        if (response?.sourceNodes) {
            sourceNodes.push(...response.sourceNodes);
        }
        responseStrs.push((0, _utils.extractText)(response.message.content));
    }
    const summary = await summarizer.getResponse({
        query: (0, _utils.extractText)(queryType),
        textChunks: responseStrs
    });
    return _schema.EngineResponse.fromResponse(summary, false, sourceNodes);
}
class RouterQueryEngine extends _index.PromptMixin {
    selector;
    queryEngines;
    metadatas;
    summarizer;
    verbose;
    constructor(init){
        super();
        this.selector = init.selector;
        this.queryEngines = init.queryEngineTools.map((tool)=>tool.queryEngine);
        this.metadatas = init.queryEngineTools.map((tool)=>({
                description: tool.description
            }));
        this.summarizer = init.summarizer || new _index2.TreeSummarize(init.serviceContext);
        this.verbose = init.verbose ?? false;
    }
    _getPromptModules() {
        return {
            selector: this.selector,
            summarizer: this.summarizer
        };
    }
    static fromDefaults(init) {
        const serviceContext = init.serviceContext;
        return new RouterQueryEngine({
            selector: init.selector ?? new _index1.LLMSingleSelector({
                llm: (0, _Settings.llmFromSettingsOrContext)(serviceContext)
            }),
            queryEngineTools: init.queryEngineTools,
            serviceContext,
            summarizer: init.summarizer,
            verbose: init.verbose
        });
    }
    async query(params) {
        const { query, stream } = params;
        const response = await this.queryRoute(query);
        if (stream) {
            throw new Error("Streaming is not supported yet.");
        }
        return response;
    }
    async queryRoute(query) {
        const result = await this.selector.select(this.metadatas, query);
        if (result.selections.length > 1) {
            const responses = [];
            for(let i = 0; i < result.selections.length; i++){
                const engineInd = result.selections[i];
                const logStr = `Selecting query engine ${engineInd.index}: ${result.selections[i].index}.`;
                if (this.verbose) {
                    console.log(logStr + "\n");
                }
                const selectedQueryEngine = this.queryEngines[engineInd.index];
                responses.push(await selectedQueryEngine.query({
                    query: (0, _utils.extractText)(query)
                }));
            }
            if (responses.length > 1) {
                const finalResponse = await combineResponses(this.summarizer, responses, query, this.verbose);
                return finalResponse;
            } else {
                return responses[0];
            }
        } else {
            let selectedQueryEngine;
            try {
                selectedQueryEngine = this.queryEngines[result.selections[0].index];
                const logStr = `Selecting query engine ${result.selections[0].index}: ${result.selections[0].reason}`;
                if (this.verbose) {
                    console.log(logStr + "\n");
                }
            } catch (e) {
                throw new Error("Failed to select query engine");
            }
            if (!selectedQueryEngine) {
                throw new Error("Selected query engine is null");
            }
            const finalResponse = await selectedQueryEngine.query({
                query: (0, _utils.extractText)(query)
            });
            // add selected result
            finalResponse.metadata = finalResponse.metadata || {};
            finalResponse.metadata["selectorResult"] = result;
            return finalResponse;
        }
    }
}
