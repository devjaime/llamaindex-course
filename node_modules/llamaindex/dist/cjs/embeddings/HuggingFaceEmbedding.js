"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HuggingFaceEmbedding: function() {
        return HuggingFaceEmbedding;
    },
    HuggingFaceEmbeddingModelType: function() {
        return HuggingFaceEmbeddingModelType;
    },
    HuggingFaceInferenceAPIEmbedding: function() {
        return HuggingFaceInferenceAPIEmbedding;
    }
});
const _inference = require("@huggingface/inference");
const _embeddings = require("@llamaindex/core/embeddings");
const _transformers = require("../internal/deps/transformers.js");
var HuggingFaceEmbeddingModelType;
(function(HuggingFaceEmbeddingModelType) {
    HuggingFaceEmbeddingModelType["XENOVA_ALL_MINILM_L6_V2"] = "Xenova/all-MiniLM-L6-v2";
    HuggingFaceEmbeddingModelType["XENOVA_ALL_MPNET_BASE_V2"] = "Xenova/all-mpnet-base-v2";
})(HuggingFaceEmbeddingModelType || (HuggingFaceEmbeddingModelType = {}));
class HuggingFaceEmbedding extends _embeddings.BaseEmbedding {
    modelType = "Xenova/all-MiniLM-L6-v2";
    quantized = true;
    extractor;
    constructor(init){
        super();
        Object.assign(this, init);
    }
    async getExtractor() {
        if (!this.extractor) {
            const { pipeline } = await (0, _transformers.lazyLoadTransformers)();
            this.extractor = await pipeline("feature-extraction", this.modelType, {
                quantized: this.quantized
            });
        }
        return this.extractor;
    }
    async getTextEmbedding(text) {
        const extractor = await this.getExtractor();
        const output = await extractor(text, {
            pooling: "mean",
            normalize: true
        });
        return Array.from(output.data);
    }
}
class HuggingFaceInferenceAPIEmbedding extends _embeddings.BaseEmbedding {
    model;
    hf;
    constructor(init){
        super();
        const { model, accessToken, endpoint, ...hfInferenceOpts } = init;
        this.hf = new _inference.HfInference(accessToken, hfInferenceOpts);
        this.model = model;
        if (endpoint) this.hf.endpoint(endpoint);
    }
    async getTextEmbedding(text) {
        const res = await this.hf.featureExtraction({
            model: this.model,
            inputs: text
        });
        return res;
    }
    getTextEmbeddings = async (texts)=>{
        const res = await this.hf.featureExtraction({
            model: this.model,
            inputs: texts
        });
        return res;
    };
}
