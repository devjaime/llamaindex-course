"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MultiModalEmbedding", {
    enumerable: true,
    get: function() {
        return MultiModalEmbedding;
    }
});
const _embeddings = require("@llamaindex/core/embeddings");
const _schema = require("@llamaindex/core/schema");
const _utils = require("@llamaindex/core/utils");
class MultiModalEmbedding extends _embeddings.BaseEmbedding {
    /**
   * Optionally override this method to retrieve multiple image embeddings in a single request
   * @param texts
   */ async getImageEmbeddings(images) {
        return Promise.all(images.map((imgFilePath)=>this.getImageEmbedding(imgFilePath)));
    }
    async transform(nodes, _options) {
        const nodeMap = (0, _schema.splitNodesByType)(nodes);
        const imageNodes = nodeMap[_schema.ModalityType.IMAGE] ?? [];
        const textNodes = nodeMap[_schema.ModalityType.TEXT] ?? [];
        const embeddings = await (0, _embeddings.batchEmbeddings)(textNodes.map((node)=>node.getContent(_schema.MetadataMode.EMBED)), this.getTextEmbeddings.bind(this), this.embedBatchSize, _options);
        for(let i = 0; i < textNodes.length; i++){
            textNodes[i].embedding = embeddings[i];
        }
        const imageEmbeddings = await (0, _embeddings.batchEmbeddings)(imageNodes.map((n)=>n.image), this.getImageEmbeddings.bind(this), this.embedBatchSize, _options);
        for(let i = 0; i < imageNodes.length; i++){
            imageNodes[i].embedding = imageEmbeddings[i];
        }
        return nodes;
    }
    async getQueryEmbedding(query) {
        const image = (0, _utils.extractImage)(query);
        if (image) {
            return await this.getImageEmbedding(image);
        }
        const text = (0, _utils.extractSingleText)(query);
        if (text) {
            return await this.getTextEmbedding(text);
        }
        return null;
    }
}
