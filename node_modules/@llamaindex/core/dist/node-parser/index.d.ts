import { z } from 'zod';
import { TransformComponent, TextNode, sentenceSplitterSchema, sentenceWindowNodeParserSchema, Document } from '../schema/index.js';
import { Tokenizer } from '@llamaindex/env';

declare abstract class NodeParser extends TransformComponent {
    includeMetadata: boolean;
    includePrevNextRel: boolean;
    constructor();
    protected postProcessParsedNodes(nodes: TextNode[], parentDocMap: Map<string, TextNode>): TextNode[];
    protected abstract parseNodes(documents: TextNode[], showProgress?: boolean): TextNode[];
    getNodesFromDocuments(documents: TextNode[]): TextNode[];
}
declare abstract class TextSplitter extends NodeParser {
    abstract splitText(text: string): string[];
    splitTexts(texts: string[]): string[];
    protected parseNodes(nodes: TextNode[]): TextNode[];
}
declare abstract class MetadataAwareTextSplitter extends TextSplitter {
    abstract splitTextMetadataAware(text: string, metadata: string): string[];
    splitTextsMetadataAware(texts: string[], metadata: string[]): string[];
    protected getMetadataString(node: TextNode): string;
    protected parseNodes(nodes: TextNode[]): TextNode[];
}

type SplitterParams = {
    tokenizer?: Tokenizer;
};

/**
 * Parse text with a preference for complete sentences.
 */
declare class SentenceSplitter extends MetadataAwareTextSplitter {
    #private;
    /**
     * The token chunk size for each chunk.
     */
    chunkSize: number;
    /**
     * The token overlap of each chunk when splitting.
     */
    chunkOverlap: number;
    /**
     * Default separator for splitting into words
     */
    separator: string;
    /**
     * Separator between paragraphs.
     */
    paragraphSeparator: string;
    /**
     * Backup regex for splitting into sentences.
     */
    secondaryChunkingRegex: string;
    constructor(params?: z.input<typeof sentenceSplitterSchema> & SplitterParams);
    splitTextMetadataAware(text: string, metadata: string): string[];
    splitText(text: string): string[];
    _splitText(text: string, chunkSize: number): string[];
    tokenSize: (text: string) => number;
}

declare class MarkdownNodeParser extends NodeParser {
    parseNodes(nodes: TextNode[], showProgress?: boolean): TextNode[];
    protected getNodesFromNode(node: TextNode): TextNode[];
    private updateMetadata;
    private buildNodeFromSplit;
}

type TextSplitterFn = (text: string) => string[];
declare const splitBySep: (sep: string, keepSep?: boolean) => TextSplitterFn;
declare const splitByChar: () => TextSplitterFn;
declare const splitBySentenceTokenizer: () => TextSplitterFn;
declare const splitByRegex: (regex: string) => TextSplitterFn;
declare const splitByPhraseRegex: () => TextSplitterFn;

declare class SentenceWindowNodeParser extends NodeParser {
    static DEFAULT_WINDOW_SIZE: number;
    static DEFAULT_WINDOW_METADATA_KEY: string;
    static DEFAULT_ORIGINAL_TEXT_METADATA_KEY: string;
    windowSize: number;
    windowMetadataKey: string;
    originalTextMetadataKey: string;
    sentenceSplitter: TextSplitterFn;
    idGenerator: () => string;
    constructor(params?: z.input<typeof sentenceWindowNodeParserSchema>);
    parseNodes(nodes: TextNode[], showProgress?: boolean): TextNode[];
    buildWindowNodesFromDocuments(documents: Document[]): TextNode[];
}

/**
 * Current logic is based on the following implementation:
 * @link @link https://github.com/run-llama/llama_index/blob/cc0ea90e7e72b8e4f5069aac981d56bb1d568323/llama-index-core/llama_index/core/node_parser
 */

/**
 * @deprecated Use `SentenceSplitter` instead
 */
declare const SimpleNodeParser: typeof SentenceSplitter;

export { MarkdownNodeParser, MetadataAwareTextSplitter, NodeParser, SentenceSplitter, SentenceWindowNodeParser, SimpleNodeParser, type SplitterParams, TextSplitter, type TextSplitterFn, splitByChar, splitByPhraseRegex, splitByRegex, splitBySentenceTokenizer, splitBySep };
