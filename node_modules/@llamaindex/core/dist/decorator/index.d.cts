declare enum NodeRelationship {
    SOURCE = "SOURCE",
    PREVIOUS = "PREVIOUS",
    NEXT = "NEXT",
    PARENT = "PARENT",
    CHILD = "CHILD"
}
declare enum ObjectType {
    TEXT = "TEXT",
    IMAGE = "IMAGE",
    INDEX = "INDEX",
    DOCUMENT = "DOCUMENT",
    IMAGE_DOCUMENT = "IMAGE_DOCUMENT"
}
declare enum MetadataMode {
    ALL = "ALL",
    EMBED = "EMBED",
    LLM = "LLM",
    NONE = "NONE"
}
type Metadata = Record<string, any>;
interface RelatedNodeInfo<T extends Metadata = Metadata> {
    nodeId: string;
    nodeType?: ObjectType;
    metadata: T;
    hash?: string;
}
type RelatedNodeType<T extends Metadata = Metadata> = RelatedNodeInfo<T> | RelatedNodeInfo<T>[];
type BaseNodeParams<T extends Metadata = Metadata> = {
    id_?: string;
    metadata?: T;
    excludedEmbedMetadataKeys?: string[];
    excludedLlmMetadataKeys?: string[];
    relationships?: Partial<Record<NodeRelationship, RelatedNodeType<T>>>;
    hash?: string;
    embedding?: number[];
};
/**
 * Generic abstract class for retrievable nodes
 */
declare abstract class BaseNode<T extends Metadata = Metadata> {
    /**
     * The unique ID of the Node/Document. The trailing underscore is here
     * to avoid collisions with the id keyword in Python.
     *
     * Set to a UUID by default.
     */
    id_: string;
    embedding?: number[];
    metadata: T;
    excludedEmbedMetadataKeys: string[];
    excludedLlmMetadataKeys: string[];
    relationships: Partial<Record<NodeRelationship, RelatedNodeType<T>>>;
    accessor hash: string;
    protected constructor(init?: BaseNodeParams<T>);
    abstract get type(): ObjectType;
    abstract getContent(metadataMode: MetadataMode): string;
    abstract getMetadataStr(metadataMode: MetadataMode): string;
    abstract setContent(value: unknown): void;
    get sourceNode(): RelatedNodeInfo<T> | undefined;
    get prevNode(): RelatedNodeInfo<T> | undefined;
    get nextNode(): RelatedNodeInfo<T> | undefined;
    get parentNode(): RelatedNodeInfo<T> | undefined;
    get childNodes(): RelatedNodeInfo<T>[] | undefined;
    abstract generateHash(): string;
    getEmbedding(): number[];
    asRelatedNodeInfo(): RelatedNodeInfo<T>;
    /**
     * Called by built in JSON.stringify (see https://javascript.info/json)
     * Properties are read-only as they are not deep-cloned (not necessary for stringification).
     * @see toMutableJSON - use to return a mutable JSON instead
     */
    toJSON(): Record<string, any>;
    clone(): BaseNode;
    /**
     * Converts the object to a JSON representation.
     * Properties can be safely modified as a deep clone of the properties are created.
     * @return {Record<string, any>} - The JSON representation of the object.
     */
    toMutableJSON(): Record<string, any>;
}

declare function chunkSizeCheck<This extends {
    id_: string;
}, Args extends any[], Return>(contentGetter: (this: This, ...args: Args) => string, _context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>): (this: This, ...args: Args) => string;
declare function lazyInitHash(value: ClassAccessorDecoratorTarget<BaseNode, string>, _context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<BaseNode, string>;

export { chunkSizeCheck, lazyInitHash };
